//3.4.2. Воспроизведение записанных позиций



#include <Dynamixel2Arduino.h>  // подключение библиотеки Dynamixel

// Последовательный порт DXL для платы STEM с OpenCM 9.04. (Если использовать DXL порт 
// на самой плате OpenCM 9.04, то нужно использовать Serial1, и из-за кода в драйвере, 
// необходимо перед dxl.begin() вызвать Serial1.setDxlMode(true).)
#define DXL_SERIAL   Serial3
#define DEBUG_SERIAL Serial // последовательный порт, подключаемый к компьютеру

const uint8_t DXL_DIR_PIN = 22; // номер информационного пина сервоприводов (28 для OpenCM 9.04)
const float DXL_PROTOCOL_VERSION = 2.0; // протокол передачи данных от OpenCM9.04 к сервоприводам

Dynamixel2Arduino dxl(DXL_SERIAL, DXL_DIR_PIN); // инициализация указателя на команды из библиотеки Dynamixel

// Импортируем имена для доступа к таблице Управления сервопривода
using namespace ControlTableItem;

#define jointN 6           // инициализация константы, обозначающей количество сервоприводов (и ненулевых столбцов массива)
#define pages 8            // задание количества строк массива помимо начального положения
int i = 0;                 // задание переменной-счетчика i
int j = 0;                 // задание переменной-счетчика j

int buf[pages+1][jointN+1]={            // инициализация двумерного массива размером (7+1=8 на 5+1=6, 8 на 6), так как в программировании нумерация
{0, 8192, 8192, 8192, 11000, 8192, 8192, }, // элементов начинается с 0. Но нулевой элемент строки мы использовать не будем, так как начнем с первого.

{0, 8192, 7400, 8000, 11000, 8192, 8192, },
{0, 8192, 7400, 8000, 11000, 8192, 6000, },
{0, 8192, 7400, 6700, 12000, 8192, 6000, },
{0, 4200, 7400, 6700, 12000, 8192, 6000, },
{0, 4200, 7400, 8000, 11000, 8192, 6000, },
{0, 4200, 7400, 8000, 11000, 8192, 8192, },
{0, 4200, 7400, 6700, 12000, 8192, 8192, },
{0, 8192, 7400, 6700, 12000, 8192, 8192, },
};

// Задание ПИД уставок:
#define P_Gain_Pos_addr 84
#define I_Gain_Pos_addr 82
#define D_Gain_Pos_addr 80
#define param_len 2
#define TIMEOUT 10
uint16_t P_Pos_param = 50;     // 640
uint16_t I_Pos_param = 0;       // 0
uint16_t D_Pos_param = 400;    // 4000


void setup() {

  DEBUG_SERIAL.begin(57600); // установка скорости обмена данными по последовательному порту компьютера
  dxl.begin(1000000);        // установка скорости обмена данными по последовательному порту манипулятора
  dxl.setPortProtocolVersion(DXL_PROTOCOL_VERSION);  // выбор протокола обмена данными
  
  for (i=1; i<=jointN; i++) {   // цикл с изменением счетчика цикла i от 1 до 5 с шагом 1 (для перебора всех 5 сервоприводов)
    dxl.torqueOff(i); // отключаем крутящий момент, когда изменяем EEPROM область в сервоприводе
    dxl.setOperatingMode(i, OP_POSITION);          // установка режима работы сервопривода с номером i в качестве шарнира
    dxl.writeControlTableItem(PROFILE_VELOCITY, i, 150); // установка скорости передвижения сервоприводов
    // Установка ПИД:
    dxl.write(i, P_Gain_Pos_addr, (uint8_t*)&P_Pos_param, param_len, TIMEOUT);
    dxl.write(i, I_Gain_Pos_addr, (uint8_t*)&I_Pos_param, param_len, TIMEOUT);
    dxl.write(i, D_Gain_Pos_addr, (uint8_t*)&D_Pos_param, param_len, TIMEOUT);
    
    dxl.torqueOn(i); // включаем крутящий момент сервопривода для удержания целевого положения сервоприводов
    dxl.setGoalPosition(i, buf[0][i]);
  }
  delay(3000);
}

void loop() {
  for (i=0; i<=pages; i++)  // цикл с изменением i от 0 до 7 с шагом 1
  {
    for(j=1; j<=jointN; j++)  // цикл с изменением j от 1 до 5 с шагом 1
      {
        dxl.setGoalPosition(j, buf[i][j]);  // задание целевого положения, получаемого из элемента ([i],[j]) сервоприводу с номером j
      }
    delay(3000);
  }
}
